/* test-eintr
 This tests the EINTR error code. It registers a handler for <ctrl-c> so
 that the user can generate a signal, and in turn blocks on either
 connect() or recv().

 Usage #1:
    test-eintr 1.2.3.4. 80
 This tries to connect to a server that doesn't exist, so the connect()
 function will have a long time-out. On BSD/macOS, hitting <ctrl-c> will
 cause this function to exit prematurely with EINTR. On Linux, this
 won't happen by default.

 Usage #2:
    test-entriy googe.com 80
This successfully connects to a web server, sends a "keep-alive" request,
so that the server won't close the connection on us. It then blocks on
the recv() function call.

 */
#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>

#include <unistd.h>
#include <sys/socket.h>
#include <netdb.h>

/* A web request with a "keep-alive" so that server won't close the connection.
 * I created this by simply copying a network packet generated by the Chrome
 * browser on my MacBook */
static const char *my_http_request =
    "GET / HTTP/1.1\r\n"
    "Host: google.com\r\n"
    "Connection: keep-alive\r\n"
    "Upgrade-Insecure-Requests: 1\r\n"
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\r\n"
    "DNT: 1\r\n"
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n"
    "Accept-Encoding: gzip, deflate\r\n"
    "Accept-Language: en-US,en;q=0.9\r\n"
    "\r\n"
    ;

/**
 * A simple signal handler. So that you can actually exit the program,
 * it unregisters itself after being caught the first time, so the user
 * hitting <ctrl-c> a second time will cause the program to exit
 */ 
static void handle_control_c(int x)
{
    fprintf(stderr, "[ ] <ctrl-c> received\n");
    signal(SIGINT, SIG_DFL);
}

static void handle_sigquit(int x)
{
    fprintf(stderr, "[ ] <ctrl-\\> received\n");
}

static void handle_alarm(int x)
{
    fprintf(stderr, "[ ] timeout received\n");
}

int main(int argc, char *argv[])
{
    struct addrinfo *addresses = NULL;
    struct addrinfo *ai;
    int err;
    int fd = -1;
    ptrdiff_t count;
    char addrname[64];
    char portname[8];

    if (argc != 3) {
        fprintf(stderr, "[-] usage: test-eintr <host> <port>\n");
        return -1;
    }

    /* Print pid so we can send other signals with `kill` command */
    fprintf(stderr, "[+] test-eintr, pid=%d\n", getpid());  

    /* Ignore the send() problem */
    signal(SIGPIPE, SIG_IGN);

    /* Register a handler for when the user hits <ctrl-c>, will cause EINTR */
    {
        struct sigaction sa;
        
        sigemptyset(&sa.sa_mask);
        sa.sa_handler = handle_control_c;
        sa.sa_flags = 0; /* will generate EINTR */
        sigaction(SIGINT, &sa, NULL);
    }
    fprintf(stderr, "[+] registered signal handler for <ctrl-c>\n");
    fprintf(stderr, "    (Press <ctrl-c> once to generate signal, twice to exit\n");

    /* Register a handler for when the user hits <ctrl-\>, will cause EINTR */
    {
        struct sigaction sa;
        
        sigemptyset(&sa.sa_mask);
        sa.sa_handler = handle_sigquit;
        sa.sa_flags = 0; /* will generate EINTR */
        sigaction(SIGQUIT, &sa, NULL);
    }
    fprintf(stderr, "[+] registered signal handler for <ctrl-\\>\n");

    /* Register a handler for an `alarm()`, won't cause EINTR */
    {
        struct sigaction sa;
        
        sigemptyset(&sa.sa_mask);
        sa.sa_handler = handle_alarm;
        sa.sa_flags = SA_RESTART; /* won't generate EINTR */
        sigaction(SIGALRM, &sa, NULL);

        /* Redundant call to make sure signal won't interrupt with EINTR */
        siginterrupt(SIGALRM, 0);
    }
    fprintf(stderr, "[+] registered signal handler for alarm in one second\n");
    alarm(1);

    /* Do a DNS lookup on the name */
    err = getaddrinfo(argv[1],      /* host name */
                      argv[2],      /* port number */
                      0,            /* hints (defaults) */
                      &addresses);  /* results */
    if (err) {
        fprintf(stderr, "[-] getaddrinfo(): %s\n", gai_strerror(err));
        return -1;
    } else {
	    count = 0;
	    for (ai=addresses; ai; ai = ai->ai_next)
	        count++;
        fprintf(stderr, "[%s] getaddrinfo(): returned %d addresses\n", 
            count?"+":"-", (int)count);
        if (count == 0)
            goto cleanup;
    }

    /* Try only the first address */
    ai = addresses;
    
    /* Pretty-print the address/port to strings for logging/debugging  */
    err = getnameinfo(ai->ai_addr, ai->ai_addrlen,
                        addrname, sizeof(addrname),
                        portname, sizeof(portname),
                        NI_NUMERICHOST | NI_NUMERICSERV);
    if (err) {
        fprintf(stderr, "[-] getnameinfo(): %s\n", gai_strerror(err));
        goto cleanup;
    }
    
    /* Create a socket */
    fd = socket(ai->ai_family, SOCK_STREAM, 0);
    if (fd == -1) {
        fprintf(stderr, "[-] socket(): %s\n", strerror(errno));
        goto cleanup;
    }
    
    /* Try to connect */
    connect_again:
    fprintf(stderr, "[ ] connecting to [%s]:%s\n", addrname, portname);
    err = connect(fd, ai->ai_addr, ai->ai_addrlen);
    if (err) {
        fprintf(stderr, "[-] connect([%s]:%s): %s (%d)\n", addrname, portname, 
                        strerror(errno), (int)errno);
        /*if (errno == EINTR)
            goto connect_again;
        else */ if (errno == EINTR || errno == EISCONN) {
            /* macOS/BSD and possibly others */
            fd_set fdwrite, fderr;
            FD_ZERO(&fdwrite);
            FD_ZERO(&fderr);
            FD_SET(fd, &fdwrite);
            FD_SET(fd, &fderr);
            select_again:
            err = select(fd+1, 0,  &fdwrite, &fderr, 0);
            if (err == 0)
                goto select_again;
            else if (err == -1) {
                fprintf(stderr, "[-] select([%s]:%s): %s\n", addrname, portname, strerror(errno));
                if (errno == EINTR)
                    goto select_again;
                else
                    goto cleanup;
            } else if (FD_ISSET(fd, &fderr)) {
                int opt = 0;
                socklen_t sizeof_opt = sizeof(opt);
                err = getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)&opt, &sizeof_opt);
                if (err) {
                    fprintf(stderr, "[-] getsockopt(SO_ERROR): %s\n", strerror(errno));
                } else {
                    fprintf(stderr, "[-] connect([%s]:%s): %s\n", addrname, portname, strerror(opt));
                }
                goto cleanup;
            } else if (!FD_ISSET(fd, &fdwrite)) {
                fprintf(stderr, "[-] connect([%s]:%s): %s\n", addrname, portname, "failed unknown reason");
                goto cleanup;
            }
        } else
            goto cleanup;
    }
    fprintf(stderr, "[+] connect([%s]:%s): %s\n", addrname, portname, "succeeded");
    
    /* The 'fd' socket now has a valid connection to the server, so
     * send the HTTP request */
    count = send(fd, my_http_request, strlen(my_http_request), 0);
    if (count == -1) {
        fprintf(stderr, "[-] send(): %s\n", strerror(errno));
        goto cleanup;
    }
    fprintf(stderr, "[+] send(): sent %d bytes\n", (int)count);

    /* Now dump all the bytes in response */
    for (;;) {
        char buf[256];;
        
        count = recv(fd, buf, sizeof(buf), 0);
        if (count == 0)
            break; /* opposite side closed connection */
        else if (count < 0) {
            fprintf(stderr, "[-] recv(): %s\n", strerror(errno));
            if (errno == EINTR)
                continue;
            break;
        } else
            fprintf(stderr, "[+] recv()ed %u bytes\n", (unsigned)count);
    }
    
cleanup:
    if (addresses)
        freeaddrinfo(addresses);
}

